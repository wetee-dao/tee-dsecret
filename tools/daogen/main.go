// daogen 根据 DAO 合约定义生成 GraphQL schema（查询/调用）与合约函数的类型化 API（payload 构建）。
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	daoGo := flag.String("dao", "", "path to pallets/dao/dao.go")
	outGraph := flag.String("graph", "", "output path for dao.graphqls (e.g. graph/dao.graphqls)")
	outAPI := flag.String("api", "", "output path for Go API (e.g. pkg/api/dao/payload_gen.go)")
	flag.Parse()
	if *daoGo == "" || *outGraph == "" {
		flag.Usage()
		os.Exit(1)
	}

	ops, err := extractOps(*daoGo)
	if err != nil {
		fmt.Fprintf(os.Stderr, "extract ops: %v\n", err)
		os.Exit(1)
	}

	if *outGraph != "" {
		if err := writeGraphQL(*outGraph, ops); err != nil {
			fmt.Fprintf(os.Stderr, "write graph: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("wrote", *outGraph)
	}
	if *outAPI != "" {
		if err := writeGoAPI(*outAPI, ops); err != nil {
			fmt.Fprintf(os.Stderr, "write api: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("wrote", *outAPI)
	}
}

func extractOps(daoPath string) ([]string, error) {
	src, err := os.ReadFile(daoPath)
	if err != nil {
		return nil, err
	}
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filepath.Base(daoPath), src, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	var ops []string
	ast.Inspect(f, func(n ast.Node) bool {
		gen, ok := n.(*ast.GenDecl)
		if !ok || gen.Tok != token.CONST || len(gen.Specs) == 0 {
			return true
		}
		for _, s := range gen.Specs {
			v, ok := s.(*ast.ValueSpec)
			if !ok || len(v.Names) == 0 || len(v.Values) == 0 {
				continue
			}
			name := v.Names[0].Name
			if !strings.HasPrefix(name, "OpDao") {
				continue
			}
			lit, ok := v.Values[0].(*ast.BasicLit)
			if !ok || lit.Kind != token.STRING {
				continue
			}
			val := strings.Trim(lit.Value, `"`)
			ops = append(ops, val)
		}
		return true
	})
	sort.Strings(ops)
	return ops, nil
}

func writeGraphQL(path string, ops []string) error {
	var b strings.Builder
	b.WriteString("# DAO 合约 Graph 查询与调用（由 tools/daogen 生成）\n\n")
	b.WriteString("extend type Query {\n")
	b.WriteString("  \"\"\"\n  DAO 状态 JSON（members、total_issuance、tracks、proposals 等）\n  \"\"\"\n")
	b.WriteString("  daoState: String!\n")
	b.WriteString("}\n\n")
	b.WriteString("extend type Mutation {\n")
	b.WriteString("  \"\"\"\n  执行 DAO 调用，payload 为 JSON，op 字段取值见下。\n")
	for _, op := range ops {
		b.WriteString("  # - " + op + "\n")
	}
	b.WriteString("  \"\"\"\n")
	b.WriteString("  daoCall(\n")
	b.WriteString("    \"\"\" 调用方地址（hex 或 SS58）\"\"\"\n")
	b.WriteString("    caller: String!\n")
	b.WriteString("    \"\"\" JSON 载荷，含 op 与各 op 对应字段，可用 pkg/api/dao 生成的 PayloadXxx 构建\"\"\"\n")
	b.WriteString("    payload: String!\n")
	b.WriteString("  ): Boolean!\n")
	b.WriteString("}\n")
	return os.WriteFile(path, []byte(b.String()), 0644)
}

func writeGoAPI(path string, ops []string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	pkg := filepath.Base(dir)
	if pkg == "." {
		pkg = "dao"
	}
	var b strings.Builder
	b.WriteString("// Code generated by tools/daogen. DO NOT EDIT.\n")
	b.WriteString("// 为 DAO 合约各 op 生成类型化 payload 构建函数，便于前端/服务端调用 dao_call。\n\n")
	b.WriteString("package " + pkg + "\n\n")
	b.WriteString("import \"encoding/json\"\n\n")
	b.WriteString("// Payload 为旧版 JSON 形态；dao_call 现已使用 model.DaoCall protobuf，payload 需为 base64(proto)。\n")
	b.WriteString("type Payload struct {\n")
	b.WriteString("  Op string `json:\"op\"`\n")
	b.WriteString("  InitialMembers []MemberInput `json:\"initial_members,omitempty\"`\n")
	b.WriteString("  PublicJoin     *bool   `json:\"public_join,omitempty\"`\n")
	b.WriteString("  SudoAccount    []byte  `json:\"sudo_account,omitempty\"`\n")
	b.WriteString("  DefaultTrack   *TrackInput `json:\"default_track,omitempty\"`\n")
	b.WriteString("  NewUser        []byte  `json:\"new_user,omitempty\"`\n")
	b.WriteString("  Balance        string  `json:\"balance,omitempty\"` // u128 十进制\n")
	b.WriteString("  ProposalId     uint32  `json:\"proposal_id,omitempty\"`\n")
	b.WriteString("  TrackId        uint32  `json:\"track_id,omitempty\"`\n")
	b.WriteString("  Call           *CallInput `json:\"call,omitempty\"`\n")
	b.WriteString("  Amount         string  `json:\"amount,omitempty\"`\n")
	b.WriteString("  OpinionYes     bool    `json:\"opinion_yes,omitempty\"`\n")
	b.WriteString("  LockAmount     string  `json:\"lock_amount,omitempty\"`\n")
	b.WriteString("  VoteId         uint64  `json:\"vote_id,omitempty\"`\n")
	b.WriteString("  To             []byte  `json:\"to,omitempty\"`\n")
	b.WriteString("  Value          string  `json:\"value,omitempty\"`\n")
	b.WriteString("  Spender        []byte  `json:\"spender,omitempty\"`\n")
	b.WriteString("  From           []byte  `json:\"from,omitempty\"`\n")
	b.WriteString("  SpendId        uint64  `json:\"spend_id,omitempty\"`\n")
	b.WriteString("  Track          *TrackInput `json:\"track,omitempty\"`\n")
	b.WriteString("}\n\n")
	b.WriteString("type MemberInput struct { Account []byte `json:\"account\"`; Balance string `json:\"balance\"` }\n")
	b.WriteString("type TrackInput struct {\n")
	b.WriteString("  Name string `json:\"name\"`\n")
	b.WriteString("  PreparePeriod uint32 `json:\"prepare_period\"`\n")
	b.WriteString("  MaxDeciding   uint32 `json:\"max_deciding\"`\n")
	b.WriteString("  ConfirmPeriod uint32 `json:\"confirm_period\"`\n")
	b.WriteString("  DecisionPeriod uint32 `json:\"decision_period\"`\n")
	b.WriteString("  MinEnactmentPeriod uint32 `json:\"min_enactment_period\"`\n")
	b.WriteString("  DecisionDeposit string `json:\"decision_deposit\"`\n")
	b.WriteString("  MaxBalance     string `json:\"max_balance\"`\n")
	b.WriteString("}\n")
	b.WriteString("type CallInput struct {\n")
	b.WriteString("  Contract []byte `json:\"contract,omitempty\"`\n")
	b.WriteString("  Selector []byte `json:\"selector,omitempty\"`\n")
	b.WriteString("  Input    []byte `json:\"input,omitempty\"`\n")
	b.WriteString("  Amount   string `json:\"amount,omitempty\"`\n")
	b.WriteString("  RefTimeLimit uint64 `json:\"ref_time_limit,omitempty\"`\n")
	b.WriteString("  AllowReentry bool   `json:\"allow_reentry,omitempty\"`\n")
	b.WriteString("}\n\n")
	b.WriteString("// MustPayload 将 p 序列化为 JSON，用于 dao_call(caller, payload)。\n")
	b.WriteString("func MustPayload(p Payload) string { b, _ := json.Marshal(p); return string(b) }\n\n")
	for _, op := range ops {
		funcName := opToFuncName(op)
		b.WriteString("// " + funcName + " 构建 op " + op + " 的 payload，返回 JSON 字符串。\n")
		b.WriteString("func " + funcName + "(p Payload) string { p.Op = \"" + op + "\"; return MustPayload(p) }\n\n")
	}
	return os.WriteFile(path, []byte(b.String()), 0644)
}

func opToFuncName(op string) string {
	// dao_init -> PayloadDaoInit, dao_public_join -> PayloadDaoPublicJoin
	parts := strings.Split(op, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return "Payload" + strings.Join(parts, "")
}
