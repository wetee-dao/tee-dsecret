package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"crypto/rand"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"strconv"
	"time"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/wetee-dao/tee-dsecret/pkg/model"
	sidechain "github.com/wetee-dao/tee-dsecret/side-chain"
	"golang.org/x/crypto/blake2b"
)

// UploadSecret is the resolver for the upload_secret field.
func (r *mutationResolver) UploadSecret(ctx context.Context, index string, secret string, hash string, user string) (bool, error) {
	pubkey, err := model.PubKeyFromSS58(user)
	if err != nil {
		return false, gqlerror.Errorf("PubKeyFromSS58 error:" + err.Error())
	}
	pubAddr := pubkey.H160Address()

	// parse index
	indexNum, err := strconv.ParseUint(index, 10, 64)
	if err != nil {
		return false, gqlerror.Errorf("ParseUint error:" + err.Error())
	}

	// decrypt sign data
	msg, err := rsaDecryptWithKey(rsaKey, secret)
	if err != nil {
		return false, gqlerror.Errorf("RsaDecryptWithKey error:" + err.Error())
	}

	h := blake2b.Sum256(msg)
	hashStr := fmt.Sprintf("0x%x", h)
	if hashStr != hash {
		fmt.Printf("hashStr: %s, hash: %s\n", hashStr, hash)
		return false, gqlerror.Errorf("Hash not match")
	}

	// encrypt secret
	encData, err := sideChain.EncryptSecret(msg)
	if err != nil {
		return false, gqlerror.Errorf("EncryptSecret error:" + err.Error())
	}

	// build side chain call
	call := model.TeeCall{Tx: &model.TeeCall_UploadSecret{UploadSecret: &model.UploadSecret{
		User:  pubAddr[:],
		Index: indexNum,
		Data:  encData,
		Hash:  h[:],
		Time:  uint64(time.Now().Unix()),
	}}}
	err = model.IssueReport(sideChain.GetDKG().Signer.ToSigner(), &call)
	if err != nil {
		return false, gqlerror.Errorf("GetReport error:" + err.Error())
	}

	// send upload secret call to side chain
	_, err = sidechain.SubmitTx(&model.Tx{
		Payload: &model.Tx_HubCall{
			HubCall: &model.HubCall{Call: []*model.TeeCall{&call}},
		},
	})
	if err != nil {
		return false, gqlerror.Errorf("SubmitTx error:" + err.Error())
	}

	return true, nil
}

// InitDiskKey is the resolver for the init_disk_key field.
func (r *mutationResolver) InitDiskKey(ctx context.Context, index string, user string) (bool, error) {
	pubkey, err := model.PubKeyFromSS58(user)
	if err != nil {
		return false, gqlerror.Errorf("PubKeyFromSS58 error:" + err.Error())
	}
	pubAddr := pubkey.H160Address()

	// parse index
	indexNum, err := strconv.ParseUint(index, 10, 64)
	if err != nil {
		return false, gqlerror.Errorf("ParseUint error:" + err.Error())
	}

	// 创建一个 32 字节的切片
	key := make([]byte, 32)
	_, err = rand.Read(key)
	if err != nil {
		return false, gqlerror.Errorf("生成随机数据失败: %v", err)
	}

	// encrypt secret
	encData, err := sideChain.EncryptSecret(key)
	if err != nil {
		return false, gqlerror.Errorf("EncryptSecret error:" + err.Error())
	}

	h := blake2b.Sum256(key)

	// build side chain call
	call := model.TeeCall{Tx: &model.TeeCall_InitDisk{InitDisk: &model.InitDisk{
		User:  pubAddr[:],
		Index: indexNum,
		Data:  encData,
		Hash:  h[:],
		Time:  uint64(time.Now().Unix()),
	}}}
	err = model.IssueReport(sideChain.GetDKG().Signer.ToSigner(), &call)
	if err != nil {
		return false, gqlerror.Errorf("GetReport error:" + err.Error())
	}

	// send upload secret call to side chain
	_, err = sidechain.SubmitTx(&model.Tx{
		Payload: &model.Tx_HubCall{
			HubCall: &model.HubCall{Call: []*model.TeeCall{&call}},
		},
	})
	if err != nil {
		return false, gqlerror.Errorf("SubmitTx error:" + err.Error())
	}

	return true, nil
}

// TeeReport is the resolver for the tee_report field.
func (r *queryResolver) TeeReport(ctx context.Context, hash string) (string, error) {
	// 组合报告
	result := map[string]any{
		"param":  "",
		"report": "",
	}
	bt, err := json.Marshal(result)
	if err != nil {
		return "", gqlerror.Errorf("Marshal:" + err.Error())
	}
	return string(bt), nil
}

// SecretRsa is the resolver for the secret_rsa field.
func (r *queryResolver) SecretRsa(ctx context.Context) (string, error) {
	publicKey := &rsaKey.PublicKey

	publicKeyBytes := x509.MarshalPKCS1PublicKey(publicKey)
	publicBlock := &pem.Block{
		Type:  "RSA PUBLIC KEY",
		Bytes: publicKeyBytes,
	}

	bt := pem.EncodeToMemory(publicBlock)
	return string(bt), nil
}
