package model

import (
	"encoding/json"
	"fmt"

	"github.com/ipfs/go-cid"
	mh "github.com/multiformats/go-multihash"
	"go.dedis.ch/kyber/v4"
	"go.dedis.ch/kyber/v4/group/edwards25519"
	"go.dedis.ch/kyber/v4/share"
)

// 去中心化的机密注入
type Secrets struct {
	Envs  map[string]string
	Files map[string][]byte
}

// SecretCommits
type SecretCommitJson struct {
	// Index of the Dealer in the list of participants
	Index uint32
	// Commitments generated by the Dealer
	Commitments [][]byte
	// SessionID generated by the Dealer tied to the Deal
	SessionID []byte
	// Signature from the Dealer
	Signature []byte
}

// DistKeyShare
type DistKeyShare struct {
	// Coefficients of the public polynomial holding the public key
	CommitsWrap KyberPoints `json:"Commits"`
	// PriShare of the distributed secret
	PriShareWrap PriShare `json:"PriShare"`
}

// DistKeyShare
func (d DistKeyShare) PriShare() *share.PriShare {
	return d.PriShareWrap.PriShare
}

// DistKeyShare
func (d DistKeyShare) Commitments() []kyber.Point {
	return d.CommitsWrap.Public
}

// PriShare
type PriShare struct {
	*share.PriShare
}

// Custom JSON serialization
func (d PriShare) MarshalJSON() ([]byte, error) {
	sbuf, err := d.V.MarshalBinary()
	if err != nil {
		return nil, fmt.Errorf("couldn't marshal private share: %w", err)
	}

	return json.Marshal(struct {
		I uint32
		V []byte
	}{
		I: d.I,
		V: sbuf,
	})
}

// Custom JSON deserialization
func (d *PriShare) UnmarshalJSON(bt []byte) error {
	jsonData := struct {
		I uint32
		V []byte
	}{}

	err := json.Unmarshal(bt, &jsonData)
	if err != nil {
		return err
	}

	group := edwards25519.NewBlakeSHA256Ed25519()
	key := group.Scalar()
	err = key.UnmarshalBinary(jsonData.V)
	if err != nil {
		return err
	}

	d.PriShare = &share.PriShare{
		I: jsonData.I,
		V: key,
	}

	return nil
}

type Secret struct {
	EncCmt  []byte   `json:"enc_cmt,omitempty"`  // encryption commitment
	EncScrt [][]byte `json:"enc_scrt,omitempty"` // enncrypted secret
}

func CidFromBytes(b []byte) (cid.Cid, error) {
	h, err := mh.Sum(b, mh.BLAKE2B_MIN, -1)
	if err != nil {
		return cid.Undef, err
	}
	return cid.NewCidV1(cid.Raw, h), nil
}
