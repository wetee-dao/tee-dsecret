// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dao.proto

package model

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DaoCall 为侧链 dao_call 的载荷，oneof 中每个字段对应一种 DAO 操作。
type DaoCall struct {
	// Types that are valid to be assigned to Call:
	//
	//	*DaoCall_Init
	//	*DaoCall_PublicJoin
	//	*DaoCall_Join
	//	*DaoCall_Leave
	//	*DaoCall_LeaveWithBurn
	//	*DaoCall_SubmitProposal
	//	*DaoCall_DepositProposal
	//	*DaoCall_SubmitVote
	//	*DaoCall_CancelVote
	//	*DaoCall_Unlock
	//	*DaoCall_ExecProposal
	//	*DaoCall_CancelProposal
	//	*DaoCall_Transfer
	//	*DaoCall_Approve
	//	*DaoCall_TransferFrom
	//	*DaoCall_Spend
	//	*DaoCall_Payout
	//	*DaoCall_SetPublicJoin
	//	*DaoCall_AddTrack
	//	*DaoCall_SetDefaultTrack
	Call                 isDaoCall_Call `protobuf_oneof:"call"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DaoCall) Reset()         { *m = DaoCall{} }
func (m *DaoCall) String() string { return proto.CompactTextString(m) }
func (*DaoCall) ProtoMessage()    {}
func (*DaoCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{0}
}
func (m *DaoCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoCall.Merge(m, src)
}
func (m *DaoCall) XXX_Size() int {
	return m.Size()
}
func (m *DaoCall) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoCall.DiscardUnknown(m)
}

var xxx_messageInfo_DaoCall proto.InternalMessageInfo

type isDaoCall_Call interface {
	isDaoCall_Call()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DaoCall_Init struct {
	Init *DaoInit `protobuf:"bytes,1,opt,name=init,proto3,oneof" json:"init,omitempty"`
}
type DaoCall_PublicJoin struct {
	PublicJoin *DaoPublicJoin `protobuf:"bytes,2,opt,name=public_join,json=publicJoin,proto3,oneof" json:"public_join,omitempty"`
}
type DaoCall_Join struct {
	Join *DaoJoin `protobuf:"bytes,3,opt,name=join,proto3,oneof" json:"join,omitempty"`
}
type DaoCall_Leave struct {
	Leave *DaoLeave `protobuf:"bytes,4,opt,name=leave,proto3,oneof" json:"leave,omitempty"`
}
type DaoCall_LeaveWithBurn struct {
	LeaveWithBurn *DaoLeaveWithBurn `protobuf:"bytes,5,opt,name=leave_with_burn,json=leaveWithBurn,proto3,oneof" json:"leave_with_burn,omitempty"`
}
type DaoCall_SubmitProposal struct {
	SubmitProposal *DaoSubmitProposal `protobuf:"bytes,6,opt,name=submit_proposal,json=submitProposal,proto3,oneof" json:"submit_proposal,omitempty"`
}
type DaoCall_DepositProposal struct {
	DepositProposal *DaoDepositProposal `protobuf:"bytes,7,opt,name=deposit_proposal,json=depositProposal,proto3,oneof" json:"deposit_proposal,omitempty"`
}
type DaoCall_SubmitVote struct {
	SubmitVote *DaoSubmitVote `protobuf:"bytes,8,opt,name=submit_vote,json=submitVote,proto3,oneof" json:"submit_vote,omitempty"`
}
type DaoCall_CancelVote struct {
	CancelVote *DaoCancelVote `protobuf:"bytes,9,opt,name=cancel_vote,json=cancelVote,proto3,oneof" json:"cancel_vote,omitempty"`
}
type DaoCall_Unlock struct {
	Unlock *DaoUnlock `protobuf:"bytes,10,opt,name=unlock,proto3,oneof" json:"unlock,omitempty"`
}
type DaoCall_ExecProposal struct {
	ExecProposal *DaoExecProposal `protobuf:"bytes,11,opt,name=exec_proposal,json=execProposal,proto3,oneof" json:"exec_proposal,omitempty"`
}
type DaoCall_CancelProposal struct {
	CancelProposal *DaoCancelProposal `protobuf:"bytes,12,opt,name=cancel_proposal,json=cancelProposal,proto3,oneof" json:"cancel_proposal,omitempty"`
}
type DaoCall_Transfer struct {
	Transfer *DaoTransfer `protobuf:"bytes,13,opt,name=transfer,proto3,oneof" json:"transfer,omitempty"`
}
type DaoCall_Approve struct {
	Approve *DaoApprove `protobuf:"bytes,14,opt,name=approve,proto3,oneof" json:"approve,omitempty"`
}
type DaoCall_TransferFrom struct {
	TransferFrom *DaoTransferFrom `protobuf:"bytes,15,opt,name=transfer_from,json=transferFrom,proto3,oneof" json:"transfer_from,omitempty"`
}
type DaoCall_Spend struct {
	Spend *DaoSpend `protobuf:"bytes,16,opt,name=spend,proto3,oneof" json:"spend,omitempty"`
}
type DaoCall_Payout struct {
	Payout *DaoPayout `protobuf:"bytes,17,opt,name=payout,proto3,oneof" json:"payout,omitempty"`
}
type DaoCall_SetPublicJoin struct {
	SetPublicJoin *DaoSetPublicJoin `protobuf:"bytes,18,opt,name=set_public_join,json=setPublicJoin,proto3,oneof" json:"set_public_join,omitempty"`
}
type DaoCall_AddTrack struct {
	AddTrack *DaoAddTrack `protobuf:"bytes,19,opt,name=add_track,json=addTrack,proto3,oneof" json:"add_track,omitempty"`
}
type DaoCall_SetDefaultTrack struct {
	SetDefaultTrack *DaoSetDefaultTrack `protobuf:"bytes,20,opt,name=set_default_track,json=setDefaultTrack,proto3,oneof" json:"set_default_track,omitempty"`
}

func (*DaoCall_Init) isDaoCall_Call()            {}
func (*DaoCall_PublicJoin) isDaoCall_Call()      {}
func (*DaoCall_Join) isDaoCall_Call()            {}
func (*DaoCall_Leave) isDaoCall_Call()           {}
func (*DaoCall_LeaveWithBurn) isDaoCall_Call()   {}
func (*DaoCall_SubmitProposal) isDaoCall_Call()  {}
func (*DaoCall_DepositProposal) isDaoCall_Call() {}
func (*DaoCall_SubmitVote) isDaoCall_Call()      {}
func (*DaoCall_CancelVote) isDaoCall_Call()      {}
func (*DaoCall_Unlock) isDaoCall_Call()          {}
func (*DaoCall_ExecProposal) isDaoCall_Call()    {}
func (*DaoCall_CancelProposal) isDaoCall_Call()  {}
func (*DaoCall_Transfer) isDaoCall_Call()        {}
func (*DaoCall_Approve) isDaoCall_Call()         {}
func (*DaoCall_TransferFrom) isDaoCall_Call()    {}
func (*DaoCall_Spend) isDaoCall_Call()           {}
func (*DaoCall_Payout) isDaoCall_Call()          {}
func (*DaoCall_SetPublicJoin) isDaoCall_Call()   {}
func (*DaoCall_AddTrack) isDaoCall_Call()        {}
func (*DaoCall_SetDefaultTrack) isDaoCall_Call() {}

func (m *DaoCall) GetCall() isDaoCall_Call {
	if m != nil {
		return m.Call
	}
	return nil
}

func (m *DaoCall) GetInit() *DaoInit {
	if x, ok := m.GetCall().(*DaoCall_Init); ok {
		return x.Init
	}
	return nil
}

func (m *DaoCall) GetPublicJoin() *DaoPublicJoin {
	if x, ok := m.GetCall().(*DaoCall_PublicJoin); ok {
		return x.PublicJoin
	}
	return nil
}

func (m *DaoCall) GetJoin() *DaoJoin {
	if x, ok := m.GetCall().(*DaoCall_Join); ok {
		return x.Join
	}
	return nil
}

func (m *DaoCall) GetLeave() *DaoLeave {
	if x, ok := m.GetCall().(*DaoCall_Leave); ok {
		return x.Leave
	}
	return nil
}

func (m *DaoCall) GetLeaveWithBurn() *DaoLeaveWithBurn {
	if x, ok := m.GetCall().(*DaoCall_LeaveWithBurn); ok {
		return x.LeaveWithBurn
	}
	return nil
}

func (m *DaoCall) GetSubmitProposal() *DaoSubmitProposal {
	if x, ok := m.GetCall().(*DaoCall_SubmitProposal); ok {
		return x.SubmitProposal
	}
	return nil
}

func (m *DaoCall) GetDepositProposal() *DaoDepositProposal {
	if x, ok := m.GetCall().(*DaoCall_DepositProposal); ok {
		return x.DepositProposal
	}
	return nil
}

func (m *DaoCall) GetSubmitVote() *DaoSubmitVote {
	if x, ok := m.GetCall().(*DaoCall_SubmitVote); ok {
		return x.SubmitVote
	}
	return nil
}

func (m *DaoCall) GetCancelVote() *DaoCancelVote {
	if x, ok := m.GetCall().(*DaoCall_CancelVote); ok {
		return x.CancelVote
	}
	return nil
}

func (m *DaoCall) GetUnlock() *DaoUnlock {
	if x, ok := m.GetCall().(*DaoCall_Unlock); ok {
		return x.Unlock
	}
	return nil
}

func (m *DaoCall) GetExecProposal() *DaoExecProposal {
	if x, ok := m.GetCall().(*DaoCall_ExecProposal); ok {
		return x.ExecProposal
	}
	return nil
}

func (m *DaoCall) GetCancelProposal() *DaoCancelProposal {
	if x, ok := m.GetCall().(*DaoCall_CancelProposal); ok {
		return x.CancelProposal
	}
	return nil
}

func (m *DaoCall) GetTransfer() *DaoTransfer {
	if x, ok := m.GetCall().(*DaoCall_Transfer); ok {
		return x.Transfer
	}
	return nil
}

func (m *DaoCall) GetApprove() *DaoApprove {
	if x, ok := m.GetCall().(*DaoCall_Approve); ok {
		return x.Approve
	}
	return nil
}

func (m *DaoCall) GetTransferFrom() *DaoTransferFrom {
	if x, ok := m.GetCall().(*DaoCall_TransferFrom); ok {
		return x.TransferFrom
	}
	return nil
}

func (m *DaoCall) GetSpend() *DaoSpend {
	if x, ok := m.GetCall().(*DaoCall_Spend); ok {
		return x.Spend
	}
	return nil
}

func (m *DaoCall) GetPayout() *DaoPayout {
	if x, ok := m.GetCall().(*DaoCall_Payout); ok {
		return x.Payout
	}
	return nil
}

func (m *DaoCall) GetSetPublicJoin() *DaoSetPublicJoin {
	if x, ok := m.GetCall().(*DaoCall_SetPublicJoin); ok {
		return x.SetPublicJoin
	}
	return nil
}

func (m *DaoCall) GetAddTrack() *DaoAddTrack {
	if x, ok := m.GetCall().(*DaoCall_AddTrack); ok {
		return x.AddTrack
	}
	return nil
}

func (m *DaoCall) GetSetDefaultTrack() *DaoSetDefaultTrack {
	if x, ok := m.GetCall().(*DaoCall_SetDefaultTrack); ok {
		return x.SetDefaultTrack
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DaoCall) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DaoCall_Init)(nil),
		(*DaoCall_PublicJoin)(nil),
		(*DaoCall_Join)(nil),
		(*DaoCall_Leave)(nil),
		(*DaoCall_LeaveWithBurn)(nil),
		(*DaoCall_SubmitProposal)(nil),
		(*DaoCall_DepositProposal)(nil),
		(*DaoCall_SubmitVote)(nil),
		(*DaoCall_CancelVote)(nil),
		(*DaoCall_Unlock)(nil),
		(*DaoCall_ExecProposal)(nil),
		(*DaoCall_CancelProposal)(nil),
		(*DaoCall_Transfer)(nil),
		(*DaoCall_Approve)(nil),
		(*DaoCall_TransferFrom)(nil),
		(*DaoCall_Spend)(nil),
		(*DaoCall_Payout)(nil),
		(*DaoCall_SetPublicJoin)(nil),
		(*DaoCall_AddTrack)(nil),
		(*DaoCall_SetDefaultTrack)(nil),
	}
}

// 成员 + 余额（u128 为 16 字节大端）
type DaoMember struct {
	Account              []byte   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Balance              []byte   `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoMember) Reset()         { *m = DaoMember{} }
func (m *DaoMember) String() string { return proto.CompactTextString(m) }
func (*DaoMember) ProtoMessage()    {}
func (*DaoMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{1}
}
func (m *DaoMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoMember.Merge(m, src)
}
func (m *DaoMember) XXX_Size() int {
	return m.Size()
}
func (m *DaoMember) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoMember.DiscardUnknown(m)
}

var xxx_messageInfo_DaoMember proto.InternalMessageInfo

func (m *DaoMember) GetAccount() []byte {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *DaoMember) GetBalance() []byte {
	if m != nil {
		return m.Balance
	}
	return nil
}

type DaoTrackData struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PreparePeriod        uint32   `protobuf:"varint,2,opt,name=prepare_period,json=preparePeriod,proto3" json:"prepare_period,omitempty"`
	MaxDeciding          uint32   `protobuf:"varint,3,opt,name=max_deciding,json=maxDeciding,proto3" json:"max_deciding,omitempty"`
	ConfirmPeriod        uint32   `protobuf:"varint,4,opt,name=confirm_period,json=confirmPeriod,proto3" json:"confirm_period,omitempty"`
	DecisionPeriod       uint32   `protobuf:"varint,5,opt,name=decision_period,json=decisionPeriod,proto3" json:"decision_period,omitempty"`
	MinEnactmentPeriod   uint32   `protobuf:"varint,6,opt,name=min_enactment_period,json=minEnactmentPeriod,proto3" json:"min_enactment_period,omitempty"`
	DecisionDeposit      []byte   `protobuf:"bytes,7,opt,name=decision_deposit,json=decisionDeposit,proto3" json:"decision_deposit,omitempty"`
	MaxBalance           []byte   `protobuf:"bytes,8,opt,name=max_balance,json=maxBalance,proto3" json:"max_balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoTrackData) Reset()         { *m = DaoTrackData{} }
func (m *DaoTrackData) String() string { return proto.CompactTextString(m) }
func (*DaoTrackData) ProtoMessage()    {}
func (*DaoTrackData) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{2}
}
func (m *DaoTrackData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoTrackData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoTrackData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoTrackData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoTrackData.Merge(m, src)
}
func (m *DaoTrackData) XXX_Size() int {
	return m.Size()
}
func (m *DaoTrackData) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoTrackData.DiscardUnknown(m)
}

var xxx_messageInfo_DaoTrackData proto.InternalMessageInfo

func (m *DaoTrackData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DaoTrackData) GetPreparePeriod() uint32 {
	if m != nil {
		return m.PreparePeriod
	}
	return 0
}

func (m *DaoTrackData) GetMaxDeciding() uint32 {
	if m != nil {
		return m.MaxDeciding
	}
	return 0
}

func (m *DaoTrackData) GetConfirmPeriod() uint32 {
	if m != nil {
		return m.ConfirmPeriod
	}
	return 0
}

func (m *DaoTrackData) GetDecisionPeriod() uint32 {
	if m != nil {
		return m.DecisionPeriod
	}
	return 0
}

func (m *DaoTrackData) GetMinEnactmentPeriod() uint32 {
	if m != nil {
		return m.MinEnactmentPeriod
	}
	return 0
}

func (m *DaoTrackData) GetDecisionDeposit() []byte {
	if m != nil {
		return m.DecisionDeposit
	}
	return nil
}

func (m *DaoTrackData) GetMaxBalance() []byte {
	if m != nil {
		return m.MaxBalance
	}
	return nil
}

type DaoCallContent struct {
	Contract             []byte   `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	Selector             []byte   `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	Input                []byte   `protobuf:"bytes,3,opt,name=input,proto3" json:"input,omitempty"`
	Amount               []byte   `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
	RefTimeLimit         uint64   `protobuf:"varint,5,opt,name=ref_time_limit,json=refTimeLimit,proto3" json:"ref_time_limit,omitempty"`
	AllowReentry         bool     `protobuf:"varint,6,opt,name=allow_reentry,json=allowReentry,proto3" json:"allow_reentry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoCallContent) Reset()         { *m = DaoCallContent{} }
func (m *DaoCallContent) String() string { return proto.CompactTextString(m) }
func (*DaoCallContent) ProtoMessage()    {}
func (*DaoCallContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{3}
}
func (m *DaoCallContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoCallContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoCallContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoCallContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoCallContent.Merge(m, src)
}
func (m *DaoCallContent) XXX_Size() int {
	return m.Size()
}
func (m *DaoCallContent) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoCallContent.DiscardUnknown(m)
}

var xxx_messageInfo_DaoCallContent proto.InternalMessageInfo

func (m *DaoCallContent) GetContract() []byte {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *DaoCallContent) GetSelector() []byte {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *DaoCallContent) GetInput() []byte {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *DaoCallContent) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *DaoCallContent) GetRefTimeLimit() uint64 {
	if m != nil {
		return m.RefTimeLimit
	}
	return 0
}

func (m *DaoCallContent) GetAllowReentry() bool {
	if m != nil {
		return m.AllowReentry
	}
	return false
}

type DaoInit struct {
	InitialMembers       []*DaoMember  `protobuf:"bytes,1,rep,name=initial_members,json=initialMembers,proto3" json:"initial_members,omitempty"`
	PublicJoin           bool          `protobuf:"varint,2,opt,name=public_join,json=publicJoin,proto3" json:"public_join,omitempty"`
	SudoAccount          []byte        `protobuf:"bytes,3,opt,name=sudo_account,json=sudoAccount,proto3" json:"sudo_account,omitempty"`
	DefaultTrack         *DaoTrackData `protobuf:"bytes,4,opt,name=default_track,json=defaultTrack,proto3" json:"default_track,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DaoInit) Reset()         { *m = DaoInit{} }
func (m *DaoInit) String() string { return proto.CompactTextString(m) }
func (*DaoInit) ProtoMessage()    {}
func (*DaoInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{4}
}
func (m *DaoInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoInit.Merge(m, src)
}
func (m *DaoInit) XXX_Size() int {
	return m.Size()
}
func (m *DaoInit) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoInit.DiscardUnknown(m)
}

var xxx_messageInfo_DaoInit proto.InternalMessageInfo

func (m *DaoInit) GetInitialMembers() []*DaoMember {
	if m != nil {
		return m.InitialMembers
	}
	return nil
}

func (m *DaoInit) GetPublicJoin() bool {
	if m != nil {
		return m.PublicJoin
	}
	return false
}

func (m *DaoInit) GetSudoAccount() []byte {
	if m != nil {
		return m.SudoAccount
	}
	return nil
}

func (m *DaoInit) GetDefaultTrack() *DaoTrackData {
	if m != nil {
		return m.DefaultTrack
	}
	return nil
}

type DaoPublicJoin struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoPublicJoin) Reset()         { *m = DaoPublicJoin{} }
func (m *DaoPublicJoin) String() string { return proto.CompactTextString(m) }
func (*DaoPublicJoin) ProtoMessage()    {}
func (*DaoPublicJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{5}
}
func (m *DaoPublicJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoPublicJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoPublicJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoPublicJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoPublicJoin.Merge(m, src)
}
func (m *DaoPublicJoin) XXX_Size() int {
	return m.Size()
}
func (m *DaoPublicJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoPublicJoin.DiscardUnknown(m)
}

var xxx_messageInfo_DaoPublicJoin proto.InternalMessageInfo

type DaoJoin struct {
	NewUser              []byte   `protobuf:"bytes,1,opt,name=new_user,json=newUser,proto3" json:"new_user,omitempty"`
	Balance              []byte   `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoJoin) Reset()         { *m = DaoJoin{} }
func (m *DaoJoin) String() string { return proto.CompactTextString(m) }
func (*DaoJoin) ProtoMessage()    {}
func (*DaoJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{6}
}
func (m *DaoJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoJoin.Merge(m, src)
}
func (m *DaoJoin) XXX_Size() int {
	return m.Size()
}
func (m *DaoJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoJoin.DiscardUnknown(m)
}

var xxx_messageInfo_DaoJoin proto.InternalMessageInfo

func (m *DaoJoin) GetNewUser() []byte {
	if m != nil {
		return m.NewUser
	}
	return nil
}

func (m *DaoJoin) GetBalance() []byte {
	if m != nil {
		return m.Balance
	}
	return nil
}

type DaoLeave struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoLeave) Reset()         { *m = DaoLeave{} }
func (m *DaoLeave) String() string { return proto.CompactTextString(m) }
func (*DaoLeave) ProtoMessage()    {}
func (*DaoLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{7}
}
func (m *DaoLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoLeave.Merge(m, src)
}
func (m *DaoLeave) XXX_Size() int {
	return m.Size()
}
func (m *DaoLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoLeave.DiscardUnknown(m)
}

var xxx_messageInfo_DaoLeave proto.InternalMessageInfo

type DaoLeaveWithBurn struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoLeaveWithBurn) Reset()         { *m = DaoLeaveWithBurn{} }
func (m *DaoLeaveWithBurn) String() string { return proto.CompactTextString(m) }
func (*DaoLeaveWithBurn) ProtoMessage()    {}
func (*DaoLeaveWithBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{8}
}
func (m *DaoLeaveWithBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoLeaveWithBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoLeaveWithBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoLeaveWithBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoLeaveWithBurn.Merge(m, src)
}
func (m *DaoLeaveWithBurn) XXX_Size() int {
	return m.Size()
}
func (m *DaoLeaveWithBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoLeaveWithBurn.DiscardUnknown(m)
}

var xxx_messageInfo_DaoLeaveWithBurn proto.InternalMessageInfo

type DaoSubmitProposal struct {
	Call                 *DaoCallContent `protobuf:"bytes,1,opt,name=call,proto3" json:"call,omitempty"`
	TrackId              uint32          `protobuf:"varint,2,opt,name=track_id,json=trackId,proto3" json:"track_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DaoSubmitProposal) Reset()         { *m = DaoSubmitProposal{} }
func (m *DaoSubmitProposal) String() string { return proto.CompactTextString(m) }
func (*DaoSubmitProposal) ProtoMessage()    {}
func (*DaoSubmitProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{9}
}
func (m *DaoSubmitProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSubmitProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSubmitProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSubmitProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSubmitProposal.Merge(m, src)
}
func (m *DaoSubmitProposal) XXX_Size() int {
	return m.Size()
}
func (m *DaoSubmitProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSubmitProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSubmitProposal proto.InternalMessageInfo

func (m *DaoSubmitProposal) GetCall() *DaoCallContent {
	if m != nil {
		return m.Call
	}
	return nil
}

func (m *DaoSubmitProposal) GetTrackId() uint32 {
	if m != nil {
		return m.TrackId
	}
	return 0
}

type DaoDepositProposal struct {
	ProposalId           uint32   `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Amount               []byte   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoDepositProposal) Reset()         { *m = DaoDepositProposal{} }
func (m *DaoDepositProposal) String() string { return proto.CompactTextString(m) }
func (*DaoDepositProposal) ProtoMessage()    {}
func (*DaoDepositProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{10}
}
func (m *DaoDepositProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoDepositProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoDepositProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoDepositProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoDepositProposal.Merge(m, src)
}
func (m *DaoDepositProposal) XXX_Size() int {
	return m.Size()
}
func (m *DaoDepositProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoDepositProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DaoDepositProposal proto.InternalMessageInfo

func (m *DaoDepositProposal) GetProposalId() uint32 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *DaoDepositProposal) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

type DaoSubmitVote struct {
	ProposalId           uint32   `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	OpinionYes           bool     `protobuf:"varint,2,opt,name=opinion_yes,json=opinionYes,proto3" json:"opinion_yes,omitempty"`
	LockAmount           []byte   `protobuf:"bytes,3,opt,name=lock_amount,json=lockAmount,proto3" json:"lock_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoSubmitVote) Reset()         { *m = DaoSubmitVote{} }
func (m *DaoSubmitVote) String() string { return proto.CompactTextString(m) }
func (*DaoSubmitVote) ProtoMessage()    {}
func (*DaoSubmitVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{11}
}
func (m *DaoSubmitVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSubmitVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSubmitVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSubmitVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSubmitVote.Merge(m, src)
}
func (m *DaoSubmitVote) XXX_Size() int {
	return m.Size()
}
func (m *DaoSubmitVote) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSubmitVote.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSubmitVote proto.InternalMessageInfo

func (m *DaoSubmitVote) GetProposalId() uint32 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *DaoSubmitVote) GetOpinionYes() bool {
	if m != nil {
		return m.OpinionYes
	}
	return false
}

func (m *DaoSubmitVote) GetLockAmount() []byte {
	if m != nil {
		return m.LockAmount
	}
	return nil
}

type DaoCancelVote struct {
	VoteId               uint64   `protobuf:"varint,1,opt,name=vote_id,json=voteId,proto3" json:"vote_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoCancelVote) Reset()         { *m = DaoCancelVote{} }
func (m *DaoCancelVote) String() string { return proto.CompactTextString(m) }
func (*DaoCancelVote) ProtoMessage()    {}
func (*DaoCancelVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{12}
}
func (m *DaoCancelVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoCancelVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoCancelVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoCancelVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoCancelVote.Merge(m, src)
}
func (m *DaoCancelVote) XXX_Size() int {
	return m.Size()
}
func (m *DaoCancelVote) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoCancelVote.DiscardUnknown(m)
}

var xxx_messageInfo_DaoCancelVote proto.InternalMessageInfo

func (m *DaoCancelVote) GetVoteId() uint64 {
	if m != nil {
		return m.VoteId
	}
	return 0
}

type DaoUnlock struct {
	VoteId               uint64   `protobuf:"varint,1,opt,name=vote_id,json=voteId,proto3" json:"vote_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoUnlock) Reset()         { *m = DaoUnlock{} }
func (m *DaoUnlock) String() string { return proto.CompactTextString(m) }
func (*DaoUnlock) ProtoMessage()    {}
func (*DaoUnlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{13}
}
func (m *DaoUnlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoUnlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoUnlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoUnlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoUnlock.Merge(m, src)
}
func (m *DaoUnlock) XXX_Size() int {
	return m.Size()
}
func (m *DaoUnlock) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoUnlock.DiscardUnknown(m)
}

var xxx_messageInfo_DaoUnlock proto.InternalMessageInfo

func (m *DaoUnlock) GetVoteId() uint64 {
	if m != nil {
		return m.VoteId
	}
	return 0
}

type DaoExecProposal struct {
	ProposalId           uint32   `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoExecProposal) Reset()         { *m = DaoExecProposal{} }
func (m *DaoExecProposal) String() string { return proto.CompactTextString(m) }
func (*DaoExecProposal) ProtoMessage()    {}
func (*DaoExecProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{14}
}
func (m *DaoExecProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoExecProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoExecProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoExecProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoExecProposal.Merge(m, src)
}
func (m *DaoExecProposal) XXX_Size() int {
	return m.Size()
}
func (m *DaoExecProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoExecProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DaoExecProposal proto.InternalMessageInfo

func (m *DaoExecProposal) GetProposalId() uint32 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

type DaoCancelProposal struct {
	ProposalId           uint32   `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoCancelProposal) Reset()         { *m = DaoCancelProposal{} }
func (m *DaoCancelProposal) String() string { return proto.CompactTextString(m) }
func (*DaoCancelProposal) ProtoMessage()    {}
func (*DaoCancelProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{15}
}
func (m *DaoCancelProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoCancelProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoCancelProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoCancelProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoCancelProposal.Merge(m, src)
}
func (m *DaoCancelProposal) XXX_Size() int {
	return m.Size()
}
func (m *DaoCancelProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoCancelProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DaoCancelProposal proto.InternalMessageInfo

func (m *DaoCancelProposal) GetProposalId() uint32 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

type DaoTransfer struct {
	To                   []byte   `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoTransfer) Reset()         { *m = DaoTransfer{} }
func (m *DaoTransfer) String() string { return proto.CompactTextString(m) }
func (*DaoTransfer) ProtoMessage()    {}
func (*DaoTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{16}
}
func (m *DaoTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoTransfer.Merge(m, src)
}
func (m *DaoTransfer) XXX_Size() int {
	return m.Size()
}
func (m *DaoTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_DaoTransfer proto.InternalMessageInfo

func (m *DaoTransfer) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *DaoTransfer) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoApprove struct {
	Spender              []byte   `protobuf:"bytes,1,opt,name=spender,proto3" json:"spender,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoApprove) Reset()         { *m = DaoApprove{} }
func (m *DaoApprove) String() string { return proto.CompactTextString(m) }
func (*DaoApprove) ProtoMessage()    {}
func (*DaoApprove) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{17}
}
func (m *DaoApprove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoApprove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoApprove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoApprove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoApprove.Merge(m, src)
}
func (m *DaoApprove) XXX_Size() int {
	return m.Size()
}
func (m *DaoApprove) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoApprove.DiscardUnknown(m)
}

var xxx_messageInfo_DaoApprove proto.InternalMessageInfo

func (m *DaoApprove) GetSpender() []byte {
	if m != nil {
		return m.Spender
	}
	return nil
}

func (m *DaoApprove) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoTransferFrom struct {
	From                 []byte   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To                   []byte   `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Value                []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoTransferFrom) Reset()         { *m = DaoTransferFrom{} }
func (m *DaoTransferFrom) String() string { return proto.CompactTextString(m) }
func (*DaoTransferFrom) ProtoMessage()    {}
func (*DaoTransferFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{18}
}
func (m *DaoTransferFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoTransferFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoTransferFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoTransferFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoTransferFrom.Merge(m, src)
}
func (m *DaoTransferFrom) XXX_Size() int {
	return m.Size()
}
func (m *DaoTransferFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoTransferFrom.DiscardUnknown(m)
}

var xxx_messageInfo_DaoTransferFrom proto.InternalMessageInfo

func (m *DaoTransferFrom) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *DaoTransferFrom) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *DaoTransferFrom) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DaoSpend struct {
	To                   []byte   `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	Amount               []byte   `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	TrackId              uint32   `protobuf:"varint,3,opt,name=track_id,json=trackId,proto3" json:"track_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoSpend) Reset()         { *m = DaoSpend{} }
func (m *DaoSpend) String() string { return proto.CompactTextString(m) }
func (*DaoSpend) ProtoMessage()    {}
func (*DaoSpend) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{19}
}
func (m *DaoSpend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSpend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSpend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSpend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSpend.Merge(m, src)
}
func (m *DaoSpend) XXX_Size() int {
	return m.Size()
}
func (m *DaoSpend) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSpend.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSpend proto.InternalMessageInfo

func (m *DaoSpend) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *DaoSpend) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *DaoSpend) GetTrackId() uint32 {
	if m != nil {
		return m.TrackId
	}
	return 0
}

type DaoPayout struct {
	SpendId              uint64   `protobuf:"varint,1,opt,name=spend_id,json=spendId,proto3" json:"spend_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoPayout) Reset()         { *m = DaoPayout{} }
func (m *DaoPayout) String() string { return proto.CompactTextString(m) }
func (*DaoPayout) ProtoMessage()    {}
func (*DaoPayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{20}
}
func (m *DaoPayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoPayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoPayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoPayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoPayout.Merge(m, src)
}
func (m *DaoPayout) XXX_Size() int {
	return m.Size()
}
func (m *DaoPayout) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoPayout.DiscardUnknown(m)
}

var xxx_messageInfo_DaoPayout proto.InternalMessageInfo

func (m *DaoPayout) GetSpendId() uint64 {
	if m != nil {
		return m.SpendId
	}
	return 0
}

type DaoSetPublicJoin struct {
	PublicJoin           bool     `protobuf:"varint,1,opt,name=public_join,json=publicJoin,proto3" json:"public_join,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoSetPublicJoin) Reset()         { *m = DaoSetPublicJoin{} }
func (m *DaoSetPublicJoin) String() string { return proto.CompactTextString(m) }
func (*DaoSetPublicJoin) ProtoMessage()    {}
func (*DaoSetPublicJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{21}
}
func (m *DaoSetPublicJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSetPublicJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSetPublicJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSetPublicJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSetPublicJoin.Merge(m, src)
}
func (m *DaoSetPublicJoin) XXX_Size() int {
	return m.Size()
}
func (m *DaoSetPublicJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSetPublicJoin.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSetPublicJoin proto.InternalMessageInfo

func (m *DaoSetPublicJoin) GetPublicJoin() bool {
	if m != nil {
		return m.PublicJoin
	}
	return false
}

type DaoAddTrack struct {
	Track                *DaoTrackData `protobuf:"bytes,1,opt,name=track,proto3" json:"track,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DaoAddTrack) Reset()         { *m = DaoAddTrack{} }
func (m *DaoAddTrack) String() string { return proto.CompactTextString(m) }
func (*DaoAddTrack) ProtoMessage()    {}
func (*DaoAddTrack) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{22}
}
func (m *DaoAddTrack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoAddTrack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoAddTrack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoAddTrack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoAddTrack.Merge(m, src)
}
func (m *DaoAddTrack) XXX_Size() int {
	return m.Size()
}
func (m *DaoAddTrack) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoAddTrack.DiscardUnknown(m)
}

var xxx_messageInfo_DaoAddTrack proto.InternalMessageInfo

func (m *DaoAddTrack) GetTrack() *DaoTrackData {
	if m != nil {
		return m.Track
	}
	return nil
}

type DaoSetDefaultTrack struct {
	TrackId              uint32   `protobuf:"varint,1,opt,name=track_id,json=trackId,proto3" json:"track_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoSetDefaultTrack) Reset()         { *m = DaoSetDefaultTrack{} }
func (m *DaoSetDefaultTrack) String() string { return proto.CompactTextString(m) }
func (*DaoSetDefaultTrack) ProtoMessage()    {}
func (*DaoSetDefaultTrack) Descriptor() ([]byte, []int) {
	return fileDescriptor_47a2fcf5e349a9ce, []int{23}
}
func (m *DaoSetDefaultTrack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoSetDefaultTrack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoSetDefaultTrack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoSetDefaultTrack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoSetDefaultTrack.Merge(m, src)
}
func (m *DaoSetDefaultTrack) XXX_Size() int {
	return m.Size()
}
func (m *DaoSetDefaultTrack) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoSetDefaultTrack.DiscardUnknown(m)
}

var xxx_messageInfo_DaoSetDefaultTrack proto.InternalMessageInfo

func (m *DaoSetDefaultTrack) GetTrackId() uint32 {
	if m != nil {
		return m.TrackId
	}
	return 0
}

func init() {
	proto.RegisterType((*DaoCall)(nil), "model.DaoCall")
	proto.RegisterType((*DaoMember)(nil), "model.DaoMember")
	proto.RegisterType((*DaoTrackData)(nil), "model.DaoTrackData")
	proto.RegisterType((*DaoCallContent)(nil), "model.DaoCallContent")
	proto.RegisterType((*DaoInit)(nil), "model.DaoInit")
	proto.RegisterType((*DaoPublicJoin)(nil), "model.DaoPublicJoin")
	proto.RegisterType((*DaoJoin)(nil), "model.DaoJoin")
	proto.RegisterType((*DaoLeave)(nil), "model.DaoLeave")
	proto.RegisterType((*DaoLeaveWithBurn)(nil), "model.DaoLeaveWithBurn")
	proto.RegisterType((*DaoSubmitProposal)(nil), "model.DaoSubmitProposal")
	proto.RegisterType((*DaoDepositProposal)(nil), "model.DaoDepositProposal")
	proto.RegisterType((*DaoSubmitVote)(nil), "model.DaoSubmitVote")
	proto.RegisterType((*DaoCancelVote)(nil), "model.DaoCancelVote")
	proto.RegisterType((*DaoUnlock)(nil), "model.DaoUnlock")
	proto.RegisterType((*DaoExecProposal)(nil), "model.DaoExecProposal")
	proto.RegisterType((*DaoCancelProposal)(nil), "model.DaoCancelProposal")
	proto.RegisterType((*DaoTransfer)(nil), "model.DaoTransfer")
	proto.RegisterType((*DaoApprove)(nil), "model.DaoApprove")
	proto.RegisterType((*DaoTransferFrom)(nil), "model.DaoTransferFrom")
	proto.RegisterType((*DaoSpend)(nil), "model.DaoSpend")
	proto.RegisterType((*DaoPayout)(nil), "model.DaoPayout")
	proto.RegisterType((*DaoSetPublicJoin)(nil), "model.DaoSetPublicJoin")
	proto.RegisterType((*DaoAddTrack)(nil), "model.DaoAddTrack")
	proto.RegisterType((*DaoSetDefaultTrack)(nil), "model.DaoSetDefaultTrack")
}

func init() { proto.RegisterFile("dao.proto", fileDescriptor_47a2fcf5e349a9ce) }

var fileDescriptor_47a2fcf5e349a9ce = []byte{
	// 1228 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0x5f, 0x6f, 0xdc, 0x44,
	0x10, 0x3f, 0x27, 0x97, 0xcb, 0x65, 0xce, 0x77, 0x97, 0x6c, 0x43, 0xeb, 0xf2, 0xd0, 0x3f, 0xa6,
	0xd0, 0x16, 0x89, 0x52, 0x5a, 0x24, 0x8a, 0xc4, 0x1f, 0x25, 0xb9, 0x96, 0x0b, 0xb4, 0x52, 0xe4,
	0xb4, 0xa0, 0xf2, 0x62, 0xed, 0xd9, 0x7b, 0x74, 0xa9, 0xbd, 0x6b, 0xd9, 0xeb, 0x24, 0xfd, 0x6a,
	0xbc, 0xc1, 0x13, 0x8f, 0x7c, 0x04, 0x54, 0x89, 0xef, 0x81, 0x76, 0x76, 0x7d, 0xfe, 0x13, 0x45,
	0x79, 0xf3, 0xcc, 0xfc, 0x66, 0x76, 0x67, 0x76, 0x66, 0x7e, 0x86, 0xad, 0x98, 0xca, 0x07, 0x59,
	0x2e, 0x95, 0x24, 0x1b, 0xa9, 0x8c, 0x59, 0xe2, 0xff, 0x37, 0x84, 0xcd, 0x19, 0x95, 0x07, 0x34,
	0x49, 0xc8, 0x1d, 0xe8, 0x73, 0xc1, 0x95, 0xe7, 0xdc, 0x72, 0xee, 0x8d, 0x1e, 0x4d, 0x1e, 0x20,
	0xe2, 0xc1, 0x8c, 0xca, 0x43, 0xc1, 0xd5, 0xbc, 0x17, 0xa0, 0x95, 0x7c, 0x05, 0xa3, 0xac, 0x5c,
	0x24, 0x3c, 0x0a, 0x7f, 0x97, 0x5c, 0x78, 0x6b, 0x08, 0xde, 0xad, 0xc1, 0x47, 0x68, 0xfc, 0x51,
	0x72, 0x31, 0xef, 0x05, 0x90, 0xad, 0x24, 0x1d, 0x1e, 0x3d, 0xd6, 0xbb, 0xe1, 0x2d, 0x16, 0xad,
	0xe4, 0x2e, 0x6c, 0x24, 0x8c, 0x9e, 0x30, 0xaf, 0x8f, 0xb0, 0x69, 0x0d, 0x7b, 0xae, 0xd5, 0xf3,
	0x5e, 0x60, 0xec, 0x64, 0x0f, 0xa6, 0xf8, 0x11, 0x9e, 0x72, 0xf5, 0x26, 0x5c, 0x94, 0xb9, 0xf0,
	0x36, 0xd0, 0xe5, 0x5a, 0xc7, 0xe5, 0x17, 0xae, 0xde, 0xec, 0x97, 0xb9, 0x3e, 0x62, 0x9c, 0x34,
	0x15, 0xe4, 0x00, 0xa6, 0x45, 0xb9, 0x48, 0xb9, 0x0a, 0xb3, 0x5c, 0x66, 0xb2, 0xa0, 0x89, 0x37,
	0xc0, 0x10, 0x5e, 0x1d, 0xe2, 0x18, 0x01, 0x47, 0xd6, 0x3e, 0xef, 0x05, 0x93, 0xa2, 0xa5, 0x21,
	0xcf, 0x60, 0x3b, 0x66, 0x99, 0x2c, 0x9a, 0x51, 0x36, 0x31, 0xca, 0xf5, 0x3a, 0xca, 0xcc, 0x20,
	0x1a, 0x61, 0xa6, 0x71, 0x5b, 0xa5, 0xeb, 0x6a, 0x2f, 0x73, 0x22, 0x15, 0xf3, 0x86, 0xdd, 0xba,
	0x9a, 0x8b, 0xfc, 0x2c, 0x95, 0xae, 0x01, 0x14, 0x2b, 0x49, 0x3b, 0x46, 0x54, 0x44, 0x2c, 0x31,
	0x8e, 0x5b, 0x5d, 0xc7, 0x03, 0x34, 0x56, 0x8e, 0xd1, 0x4a, 0x22, 0x9f, 0xc2, 0xa0, 0x14, 0x89,
	0x8c, 0xde, 0x7a, 0x80, 0x3e, 0xdb, 0xb5, 0xcf, 0x2b, 0xd4, 0xcf, 0x7b, 0x81, 0x45, 0x90, 0x6f,
	0x61, 0xcc, 0xce, 0x58, 0x54, 0xa7, 0x38, 0x42, 0x97, 0xab, 0xb5, 0xcb, 0xd3, 0x33, 0x16, 0x35,
	0xf2, 0x73, 0x59, 0x43, 0xd6, 0x95, 0xb6, 0x77, 0x5c, 0x05, 0x70, 0xbb, 0x95, 0x36, 0xf7, 0x6c,
	0x56, 0x3a, 0x6a, 0x69, 0xc8, 0x43, 0x18, 0xaa, 0x9c, 0x8a, 0x62, 0xc9, 0x72, 0x6f, 0x8c, 0xde,
	0xa4, 0xf6, 0x7e, 0x69, 0x2d, 0xf3, 0x5e, 0xb0, 0x42, 0x91, 0xcf, 0x60, 0x93, 0x66, 0x59, 0x2e,
	0x4f, 0x98, 0x37, 0x41, 0x87, 0x9d, 0xda, 0x61, 0xcf, 0x18, 0xe6, 0xbd, 0xa0, 0xc2, 0xe8, 0x24,
	0x2b, 0xd7, 0x70, 0x99, 0xcb, 0xd4, 0x9b, 0x76, 0x93, 0xac, 0x4e, 0x79, 0x96, 0xcb, 0x54, 0x27,
	0xa9, 0x1a, 0xb2, 0x6e, 0xdd, 0x22, 0x63, 0x22, 0xf6, 0xb6, 0xbb, 0xad, 0x7b, 0xac, 0xd5, 0xba,
	0x75, 0xd1, 0xae, 0x0b, 0x9f, 0xd1, 0x77, 0xb2, 0x54, 0xde, 0x4e, 0xb7, 0xf0, 0x47, 0xa8, 0xd7,
	0x85, 0x37, 0x08, 0xdd, 0xe6, 0x05, 0x53, 0x61, 0x73, 0xe4, 0x48, 0xb7, 0xcd, 0x8f, 0x99, 0x6a,
	0x4d, 0xdd, 0xb8, 0x68, 0x2a, 0xc8, 0x17, 0xb0, 0x45, 0xe3, 0x38, 0x54, 0x39, 0x8d, 0xde, 0x7a,
	0x57, 0xba, 0x85, 0xdb, 0x8b, 0xe3, 0x97, 0xda, 0xa2, 0x0b, 0x47, 0xed, 0x37, 0xf9, 0x01, 0x76,
	0xf4, 0xa9, 0x31, 0x5b, 0xd2, 0x32, 0x51, 0xd6, 0x75, 0xb7, 0xdb, 0xd5, 0xc7, 0x4c, 0xcd, 0x0c,
	0xa2, 0x8a, 0xa0, 0xef, 0xda, 0x54, 0xed, 0x0f, 0xa0, 0x1f, 0xd1, 0x24, 0xf1, 0xbf, 0x87, 0xad,
	0x19, 0x95, 0x2f, 0x58, 0xba, 0x60, 0x39, 0xf1, 0x60, 0x93, 0x46, 0x91, 0x2c, 0x85, 0xd9, 0x35,
	0x6e, 0x50, 0x89, 0xda, 0xb2, 0xa0, 0x89, 0x7e, 0x76, 0x5c, 0x2c, 0x6e, 0x50, 0x89, 0xfe, 0x1f,
	0x6b, 0xe0, 0x9a, 0x07, 0x88, 0xde, 0xce, 0xa8, 0xa2, 0x84, 0x40, 0x5f, 0xd0, 0x94, 0x61, 0x84,
	0xad, 0x00, 0xbf, 0xc9, 0xc7, 0x30, 0xc9, 0x72, 0x96, 0xd1, 0x9c, 0x85, 0x19, 0xcb, 0xb9, 0x8c,
	0x31, 0xca, 0x38, 0x18, 0x5b, 0xed, 0x11, 0x2a, 0xc9, 0x6d, 0x70, 0x53, 0x7a, 0x16, 0xc6, 0x2c,
	0xe2, 0x31, 0x17, 0xbf, 0xe1, 0x46, 0x1a, 0x07, 0xa3, 0x94, 0x9e, 0xcd, 0xac, 0x4a, 0x47, 0x8a,
	0xa4, 0x58, 0xf2, 0x3c, 0xad, 0x22, 0xf5, 0x4d, 0x24, 0xab, 0xb5, 0x91, 0xee, 0xc2, 0x54, 0x47,
	0x29, 0xb8, 0x14, 0x15, 0x6e, 0x03, 0x71, 0x93, 0x4a, 0x6d, 0x81, 0x0f, 0x61, 0x37, 0xe5, 0x22,
	0x64, 0x82, 0x46, 0x2a, 0x65, 0x42, 0x55, 0xe8, 0x01, 0xa2, 0x49, 0xca, 0xc5, 0xd3, 0xca, 0x64,
	0x3d, 0xee, 0xeb, 0xbd, 0x62, 0x43, 0xdb, 0x5d, 0x81, 0x7b, 0xc5, 0x0d, 0x56, 0x47, 0xda, 0xad,
	0x42, 0x6e, 0x82, 0xbe, 0x7b, 0x58, 0x55, 0x6e, 0x88, 0x28, 0x48, 0xe9, 0xd9, 0xbe, 0x2d, 0xde,
	0x9f, 0x0e, 0x4c, 0xec, 0x96, 0x3f, 0x90, 0x42, 0x31, 0xa1, 0xc8, 0x87, 0x30, 0x8c, 0xa4, 0xd0,
	0x0f, 0x5b, 0x3d, 0xc2, 0x4a, 0xd6, 0xb6, 0x82, 0x25, 0x2c, 0x52, 0x32, 0xb7, 0xcf, 0xb0, 0x92,
	0xc9, 0x2e, 0x6c, 0x70, 0x91, 0x95, 0x0a, 0x8b, 0xe6, 0x06, 0x46, 0x20, 0x57, 0x61, 0x40, 0x53,
	0x7c, 0xd0, 0x3e, 0xaa, 0xad, 0x44, 0xee, 0xc0, 0x24, 0x67, 0xcb, 0x50, 0xf1, 0x94, 0x85, 0x09,
	0x4f, 0xb9, 0xc2, 0xf2, 0xf4, 0x03, 0x37, 0x67, 0xcb, 0x97, 0x3c, 0x65, 0xcf, 0xb5, 0x8e, 0x7c,
	0x04, 0x63, 0x9a, 0x24, 0xf2, 0x34, 0xcc, 0x19, 0x13, 0x2a, 0x7f, 0x87, 0x55, 0x19, 0x06, 0x2e,
	0x2a, 0x03, 0xa3, 0xf3, 0xff, 0x72, 0x90, 0xa9, 0x34, 0x17, 0x91, 0xaf, 0x61, 0xaa, 0xb9, 0x88,
	0xd3, 0x24, 0x4c, 0xb1, 0xa5, 0x0a, 0xcf, 0xb9, 0xb5, 0xde, 0x9e, 0x24, 0xd3, 0x6b, 0xc1, 0xc4,
	0x02, 0x8d, 0x58, 0xe8, 0x5a, 0x75, 0xe9, 0x6b, 0xd8, 0xa2, 0xa9, 0xdb, 0xe0, 0x16, 0x65, 0x2c,
	0xc3, 0xaa, 0x43, 0x4d, 0x9e, 0x23, 0xad, 0xdb, 0xb3, 0x5d, 0xfa, 0x04, 0xc6, 0xed, 0xc9, 0x30,
	0x5c, 0x75, 0xa5, 0xb5, 0x27, 0x4c, 0x9b, 0x06, 0x6e, 0xdc, 0x18, 0x07, 0x7f, 0x0a, 0xe3, 0x16,
	0x45, 0xfa, 0xdf, 0x61, 0x52, 0x78, 0xf0, 0x75, 0x18, 0x0a, 0x76, 0x1a, 0x96, 0x05, 0xcb, 0xab,
	0xb1, 0x10, 0xec, 0xf4, 0x55, 0x61, 0x06, 0xe6, 0x82, 0xb1, 0x00, 0x18, 0x56, 0x3c, 0xe7, 0x13,
	0xd8, 0xee, 0x72, 0x9e, 0xff, 0x1a, 0x76, 0xce, 0x91, 0x18, 0xb9, 0x6f, 0x86, 0xd2, 0x12, 0xfd,
	0x07, 0xcd, 0x15, 0xbc, 0x6a, 0x90, 0x00, 0x21, 0xfa, 0x52, 0x98, 0x62, 0xc8, 0xab, 0x59, 0xda,
	0x44, 0xf9, 0x30, 0xf6, 0x5f, 0x00, 0x39, 0xcf, 0x6c, 0x58, 0x5f, 0xfb, 0xad, 0x7d, 0x1c, 0xf4,
	0x81, 0x4a, 0x75, 0x18, 0x37, 0x5a, 0x65, 0xad, 0xd9, 0x2a, 0x7e, 0x8e, 0xa5, 0xa9, 0x59, 0xee,
	0xf2, 0x48, 0x37, 0x61, 0x24, 0x33, 0x2e, 0xf4, 0x80, 0xbc, 0x63, 0x45, 0xf5, 0x94, 0x56, 0xf5,
	0x9a, 0xe1, 0x5b, 0x6b, 0xf2, 0x0a, 0xed, 0x79, 0xe6, 0x25, 0x41, 0xab, 0xf6, 0xcc, 0x99, 0xf7,
	0xf0, 0xcc, 0x9a, 0x20, 0xc9, 0x35, 0xd8, 0xd4, 0x24, 0x5a, 0x9d, 0xd7, 0x0f, 0x06, 0x5a, 0x3c,
	0x8c, 0xfd, 0x3b, 0xb8, 0xbf, 0x0c, 0x2d, 0x5e, 0x8c, 0x7a, 0x04, 0xd3, 0x0e, 0x13, 0x5e, 0x9a,
	0x85, 0xff, 0x25, 0xbe, 0x50, 0x9b, 0xfc, 0x2e, 0xf7, 0x7a, 0x0c, 0xa3, 0x06, 0x1d, 0x91, 0x09,
	0xac, 0x29, 0x69, 0xbb, 0x66, 0x4d, 0x49, 0x3d, 0xa5, 0x27, 0x34, 0x29, 0xab, 0x76, 0x31, 0x82,
	0xff, 0x0d, 0x40, 0x4d, 0x7c, 0xba, 0xa9, 0x90, 0x8e, 0xea, 0x76, 0xb3, 0xe2, 0x05, 0xde, 0x3f,
	0x61, 0x72, 0x4d, 0x06, 0xd4, 0x3b, 0x18, 0x79, 0xd2, 0xf8, 0xe3, 0xb7, 0xbd, 0xca, 0xda, 0xf9,
	0xab, 0xac, 0x37, 0x83, 0xbd, 0xc0, 0xbe, 0x45, 0x5e, 0x3c, 0x77, 0xf9, 0x0b, 0x3a, 0xa4, 0xd5,
	0x8b, 0xeb, 0xed, 0x5e, 0xfc, 0x04, 0x9f, 0xc7, 0x90, 0xa7, 0xc6, 0x61, 0x26, 0xf5, 0xfb, 0x98,
	0xcc, 0xb0, 0x6c, 0xdb, 0x5d, 0xbe, 0xec, 0x6e, 0x04, 0xa7, 0xbb, 0x11, 0xfc, 0x27, 0x58, 0xeb,
	0x8a, 0x27, 0xc9, 0x7d, 0xd8, 0x30, 0x53, 0xef, 0x5c, 0x3c, 0xf5, 0x06, 0xe1, 0x7f, 0x8e, 0x23,
	0xd2, 0xa1, 0xc9, 0x56, 0x1e, 0x4e, 0x2b, 0x8f, 0xfd, 0xc9, 0xdf, 0xef, 0x6f, 0x38, 0xff, 0xbc,
	0xbf, 0xe1, 0xfc, 0xfb, 0xfe, 0x86, 0xf3, 0x6b, 0x6f, 0x31, 0xc0, 0x9f, 0xf5, 0xc7, 0xff, 0x07,
	0x00, 0x00, 0xff, 0xff, 0x44, 0x37, 0xc7, 0xa0, 0xb9, 0x0b, 0x00, 0x00,
}

func (m *DaoCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Call != nil {
		{
			size := m.Call.Size()
			i -= size
			if _, err := m.Call.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DaoCall_Init) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Init) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Init != nil {
		{
			size, err := m.Init.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_PublicJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_PublicJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicJoin != nil {
		{
			size, err := m.PublicJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Leave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Leave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Leave != nil {
		{
			size, err := m.Leave.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_LeaveWithBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_LeaveWithBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaveWithBurn != nil {
		{
			size, err := m.LeaveWithBurn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_SubmitProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_SubmitProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubmitProposal != nil {
		{
			size, err := m.SubmitProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_DepositProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_DepositProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DepositProposal != nil {
		{
			size, err := m.DepositProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_SubmitVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_SubmitVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubmitVote != nil {
		{
			size, err := m.SubmitVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_CancelVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_CancelVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelVote != nil {
		{
			size, err := m.CancelVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Unlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Unlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Unlock != nil {
		{
			size, err := m.Unlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_ExecProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_ExecProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExecProposal != nil {
		{
			size, err := m.ExecProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_CancelProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_CancelProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelProposal != nil {
		{
			size, err := m.CancelProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Transfer != nil {
		{
			size, err := m.Transfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Approve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Approve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Approve != nil {
		{
			size, err := m.Approve.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_TransferFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_TransferFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TransferFrom != nil {
		{
			size, err := m.TransferFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Spend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Spend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Spend != nil {
		{
			size, err := m.Spend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_Payout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_Payout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Payout != nil {
		{
			size, err := m.Payout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_SetPublicJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_SetPublicJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetPublicJoin != nil {
		{
			size, err := m.SetPublicJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_AddTrack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_AddTrack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTrack != nil {
		{
			size, err := m.AddTrack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *DaoCall_SetDefaultTrack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCall_SetDefaultTrack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetDefaultTrack != nil {
		{
			size, err := m.SetDefaultTrack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *DaoMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Balance) > 0 {
		i -= len(m.Balance)
		copy(dAtA[i:], m.Balance)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Balance)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoTrackData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoTrackData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoTrackData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MaxBalance) > 0 {
		i -= len(m.MaxBalance)
		copy(dAtA[i:], m.MaxBalance)
		i = encodeVarintDao(dAtA, i, uint64(len(m.MaxBalance)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DecisionDeposit) > 0 {
		i -= len(m.DecisionDeposit)
		copy(dAtA[i:], m.DecisionDeposit)
		i = encodeVarintDao(dAtA, i, uint64(len(m.DecisionDeposit)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MinEnactmentPeriod != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.MinEnactmentPeriod))
		i--
		dAtA[i] = 0x30
	}
	if m.DecisionPeriod != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.DecisionPeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.ConfirmPeriod != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.ConfirmPeriod))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDeciding != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.MaxDeciding))
		i--
		dAtA[i] = 0x18
	}
	if m.PreparePeriod != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.PreparePeriod))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoCallContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoCallContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCallContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowReentry {
		i--
		if m.AllowReentry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.RefTimeLimit != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.RefTimeLimit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Input) > 0 {
		i -= len(m.Input)
		copy(dAtA[i:], m.Input)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Input)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Selector) > 0 {
		i -= len(m.Selector)
		copy(dAtA[i:], m.Selector)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Selector)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DefaultTrack != nil {
		{
			size, err := m.DefaultTrack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SudoAccount) > 0 {
		i -= len(m.SudoAccount)
		copy(dAtA[i:], m.SudoAccount)
		i = encodeVarintDao(dAtA, i, uint64(len(m.SudoAccount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PublicJoin {
		i--
		if m.PublicJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.InitialMembers) > 0 {
		for iNdEx := len(m.InitialMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitialMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDao(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DaoPublicJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoPublicJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoPublicJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DaoJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Balance) > 0 {
		i -= len(m.Balance)
		copy(dAtA[i:], m.Balance)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Balance)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NewUser) > 0 {
		i -= len(m.NewUser)
		copy(dAtA[i:], m.NewUser)
		i = encodeVarintDao(dAtA, i, uint64(len(m.NewUser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DaoLeaveWithBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoLeaveWithBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoLeaveWithBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DaoSubmitProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSubmitProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSubmitProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TrackId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.TrackId))
		i--
		dAtA[i] = 0x10
	}
	if m.Call != nil {
		{
			size, err := m.Call.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoDepositProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoDepositProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoDepositProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoSubmitVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSubmitVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSubmitVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LockAmount) > 0 {
		i -= len(m.LockAmount)
		copy(dAtA[i:], m.LockAmount)
		i = encodeVarintDao(dAtA, i, uint64(len(m.LockAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OpinionYes {
		i--
		if m.OpinionYes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ProposalId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoCancelVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoCancelVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCancelVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VoteId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.VoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoUnlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoUnlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoUnlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VoteId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.VoteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoExecProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoExecProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoExecProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProposalId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoCancelProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoCancelProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoCancelProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProposalId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintDao(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoApprove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoApprove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoApprove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Spender) > 0 {
		i -= len(m.Spender)
		copy(dAtA[i:], m.Spender)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Spender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoTransferFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoTransferFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoTransferFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintDao(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintDao(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoSpend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSpend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSpend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TrackId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.TrackId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintDao(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintDao(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoPayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoPayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoPayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SpendId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.SpendId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoSetPublicJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSetPublicJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSetPublicJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PublicJoin {
		i--
		if m.PublicJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DaoAddTrack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoAddTrack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoAddTrack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Track != nil {
		{
			size, err := m.Track.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDao(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaoSetDefaultTrack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoSetDefaultTrack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaoSetDefaultTrack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TrackId != 0 {
		i = encodeVarintDao(dAtA, i, uint64(m.TrackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDao(dAtA []byte, offset int, v uint64) int {
	offset -= sovDao(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DaoCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Call != nil {
		n += m.Call.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoCall_Init) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Init != nil {
		l = m.Init.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_PublicJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicJoin != nil {
		l = m.PublicJoin.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Leave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leave != nil {
		l = m.Leave.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_LeaveWithBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaveWithBurn != nil {
		l = m.LeaveWithBurn.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_SubmitProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmitProposal != nil {
		l = m.SubmitProposal.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_DepositProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DepositProposal != nil {
		l = m.DepositProposal.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_SubmitVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmitVote != nil {
		l = m.SubmitVote.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_CancelVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelVote != nil {
		l = m.CancelVote.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Unlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unlock != nil {
		l = m.Unlock.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_ExecProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecProposal != nil {
		l = m.ExecProposal.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_CancelProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelProposal != nil {
		l = m.CancelProposal.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transfer != nil {
		l = m.Transfer.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Approve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Approve != nil {
		l = m.Approve.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_TransferFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransferFrom != nil {
		l = m.TransferFrom.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Spend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spend != nil {
		l = m.Spend.Size()
		n += 2 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_Payout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payout != nil {
		l = m.Payout.Size()
		n += 2 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_SetPublicJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetPublicJoin != nil {
		l = m.SetPublicJoin.Size()
		n += 2 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_AddTrack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTrack != nil {
		l = m.AddTrack.Size()
		n += 2 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoCall_SetDefaultTrack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetDefaultTrack != nil {
		l = m.SetDefaultTrack.Size()
		n += 2 + l + sovDao(uint64(l))
	}
	return n
}
func (m *DaoMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Balance)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoTrackData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.PreparePeriod != 0 {
		n += 1 + sovDao(uint64(m.PreparePeriod))
	}
	if m.MaxDeciding != 0 {
		n += 1 + sovDao(uint64(m.MaxDeciding))
	}
	if m.ConfirmPeriod != 0 {
		n += 1 + sovDao(uint64(m.ConfirmPeriod))
	}
	if m.DecisionPeriod != 0 {
		n += 1 + sovDao(uint64(m.DecisionPeriod))
	}
	if m.MinEnactmentPeriod != 0 {
		n += 1 + sovDao(uint64(m.MinEnactmentPeriod))
	}
	l = len(m.DecisionDeposit)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.MaxBalance)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoCallContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Selector)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.RefTimeLimit != 0 {
		n += 1 + sovDao(uint64(m.RefTimeLimit))
	}
	if m.AllowReentry {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InitialMembers) > 0 {
		for _, e := range m.InitialMembers {
			l = e.Size()
			n += 1 + l + sovDao(uint64(l))
		}
	}
	if m.PublicJoin {
		n += 2
	}
	l = len(m.SudoAccount)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.DefaultTrack != nil {
		l = m.DefaultTrack.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoPublicJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewUser)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Balance)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoLeaveWithBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoSubmitProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Call != nil {
		l = m.Call.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	if m.TrackId != 0 {
		n += 1 + sovDao(uint64(m.TrackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoDepositProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovDao(uint64(m.ProposalId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoSubmitVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovDao(uint64(m.ProposalId))
	}
	if m.OpinionYes {
		n += 2
	}
	l = len(m.LockAmount)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoCancelVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteId != 0 {
		n += 1 + sovDao(uint64(m.VoteId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoUnlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteId != 0 {
		n += 1 + sovDao(uint64(m.VoteId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoExecProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovDao(uint64(m.ProposalId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoCancelProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovDao(uint64(m.ProposalId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoApprove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Spender)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoTransferFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoSpend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovDao(uint64(l))
	}
	if m.TrackId != 0 {
		n += 1 + sovDao(uint64(m.TrackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoPayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpendId != 0 {
		n += 1 + sovDao(uint64(m.SpendId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoSetPublicJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicJoin {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoAddTrack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Track != nil {
		l = m.Track.Size()
		n += 1 + l + sovDao(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoSetDefaultTrack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackId != 0 {
		n += 1 + sovDao(uint64(m.TrackId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDao(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDao(x uint64) (n int) {
	return sovDao(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DaoCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoInit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Init{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoPublicJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_PublicJoin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Join{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoLeave{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Leave{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveWithBurn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoLeaveWithBurn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_LeaveWithBurn{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoSubmitProposal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_SubmitProposal{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoDepositProposal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_DepositProposal{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoSubmitVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_SubmitVote{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoCancelVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_CancelVote{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoUnlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Unlock{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoExecProposal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_ExecProposal{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoCancelProposal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_CancelProposal{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoTransfer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Transfer{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoApprove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Approve{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoTransferFrom{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_TransferFrom{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoSpend{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Spend{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoPayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_Payout{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetPublicJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoSetPublicJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_SetPublicJoin{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTrack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoAddTrack{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_AddTrack{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetDefaultTrack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DaoSetDefaultTrack{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Call = &DaoCall_SetDefaultTrack{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = append(m.Account[:0], dAtA[iNdEx:postIndex]...)
			if m.Account == nil {
				m.Account = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = append(m.Balance[:0], dAtA[iNdEx:postIndex]...)
			if m.Balance == nil {
				m.Balance = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoTrackData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoTrackData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoTrackData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparePeriod", wireType)
			}
			m.PreparePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparePeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeciding", wireType)
			}
			m.MaxDeciding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDeciding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmPeriod", wireType)
			}
			m.ConfirmPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPeriod", wireType)
			}
			m.DecisionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEnactmentPeriod", wireType)
			}
			m.MinEnactmentPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEnactmentPeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionDeposit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionDeposit = append(m.DecisionDeposit[:0], dAtA[iNdEx:postIndex]...)
			if m.DecisionDeposit == nil {
				m.DecisionDeposit = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBalance", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxBalance = append(m.MaxBalance[:0], dAtA[iNdEx:postIndex]...)
			if m.MaxBalance == nil {
				m.MaxBalance = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoCallContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoCallContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoCallContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = append(m.Contract[:0], dAtA[iNdEx:postIndex]...)
			if m.Contract == nil {
				m.Contract = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selector = append(m.Selector[:0], dAtA[iNdEx:postIndex]...)
			if m.Selector == nil {
				m.Selector = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input[:0], dAtA[iNdEx:postIndex]...)
			if m.Input == nil {
				m.Input = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTimeLimit", wireType)
			}
			m.RefTimeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefTimeLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReentry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowReentry = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialMembers = append(m.InitialMembers, &DaoMember{})
			if err := m.InitialMembers[len(m.InitialMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicJoin = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SudoAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SudoAccount = append(m.SudoAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.SudoAccount == nil {
				m.SudoAccount = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTrack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultTrack == nil {
				m.DefaultTrack = &DaoTrackData{}
			}
			if err := m.DefaultTrack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoPublicJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoPublicJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoPublicJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewUser", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewUser = append(m.NewUser[:0], dAtA[iNdEx:postIndex]...)
			if m.NewUser == nil {
				m.NewUser = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = append(m.Balance[:0], dAtA[iNdEx:postIndex]...)
			if m.Balance == nil {
				m.Balance = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoLeaveWithBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoLeaveWithBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoLeaveWithBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSubmitProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSubmitProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSubmitProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Call", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Call == nil {
				m.Call = &DaoCallContent{}
			}
			if err := m.Call.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
			m.TrackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoDepositProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoDepositProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoDepositProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSubmitVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSubmitVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSubmitVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpinionYes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpinionYes = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockAmount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockAmount = append(m.LockAmount[:0], dAtA[iNdEx:postIndex]...)
			if m.LockAmount == nil {
				m.LockAmount = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoCancelVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoCancelVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoCancelVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteId", wireType)
			}
			m.VoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoUnlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoUnlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoUnlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteId", wireType)
			}
			m.VoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoteId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoExecProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoExecProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoExecProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoCancelProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoCancelProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoCancelProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoApprove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoApprove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoApprove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spender = append(m.Spender[:0], dAtA[iNdEx:postIndex]...)
			if m.Spender == nil {
				m.Spender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoTransferFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoTransferFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoTransferFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSpend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSpend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSpend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
			m.TrackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoPayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoPayout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoPayout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendId", wireType)
			}
			m.SpendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpendId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSetPublicJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSetPublicJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSetPublicJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicJoin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoAddTrack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoAddTrack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoAddTrack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Track", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDao
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDao
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Track == nil {
				m.Track = &DaoTrackData{}
			}
			if err := m.Track.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoSetDefaultTrack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDao
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoSetDefaultTrack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoSetDefaultTrack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
			m.TrackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDao
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDao(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDao
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDao(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDao
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDao
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDao
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDao
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDao
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDao
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDao        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDao          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDao = fmt.Errorf("proto: unexpected end of group")
)
